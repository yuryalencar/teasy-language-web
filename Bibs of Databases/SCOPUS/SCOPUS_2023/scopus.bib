Scopus
EXPORT DATE: 15 January 2023

@ARTICLE{Oliveira2022,
author={Oliveira, D.F. and Gomes, J.P. and Pereira, R.B. and Brito, M.A. and Machado, R.J.},
title={Development of a Self-diagnostic System Integrated into a Cyber-Physical System},
journal={Computers},
year={2022},
volume={11},
number={9},
doi={10.3390/computers11090131},
art_number={131},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85138826836&doi=10.3390%2fcomputers11090131&partnerID=40&md5=ea93f5f613b55f3ea9eff46373499a26},
affiliation={Department of Informatics and Computing, University Mandume Ya Ndemufayo, Lubango, 3FJP+27X, Angola; Centro Algoritmi, Department of Information Systems, University of Minho, Guimarães, 4800-058, Portugal; Department of Information Systems, University of Minho, Guimarães, 4804-533, Portugal; Department of Informatics, University of Minho, Braga, 4710-057, Portugal},
abstract={CONTROLAR provides Bosch with an intelligent functional testing machine used to test the correct functioning of the car radios produced. During this process, the radios are submitted to several tests, raising the problem of how the machine detects errors in several radios consecutively, making it impossible to know if the device has a problem since it has no module to see if it works correctly. This article arises from the need to find a solution to solve this problem, which was to develop a self-diagnostic system that will ensure the reliability and integrity of the cyber-physical system, passing a detailed state of the art. The development of this system was based on the design of an architecture that combines the KDT methodology with a DSL to manage and configure the tests to integrate the self-diagnostic test system into a CPS. A total of 28 test cases were performed to cover all its functionalities. The results show that all test cases passed. Therefore, the system meets all the proposed objectives. © 2022 by the authors.},
author_keywords={cyber-physical systems;  self-diagnosis;  test automation;  web application},
document_type={Article},
source={Scopus},
}

@CONFERENCE{Othman202218,
author={Othman, R. and Zein, S.},
title={Test Case Auto-Generation for Web Applications: A Model-Based Approach},
journal={ISMSIT 2022 - 6th International Symposium on Multidisciplinary Studies and Innovative Technologies, Proceedings},
year={2022},
pages={18-25},
doi={10.1109/ISMSIT56059.2022.9932797},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85142807877&doi=10.1109%2fISMSIT56059.2022.9932797&partnerID=40&md5=de6ce1a6c8bf5d3afbcfb7c0687abdf3},
affiliation={Master of Software Engineering, Birzeit University, Palestine},
abstract={Web applications are prevalent and considered the mainstay of information systems for organizations. At the same time, web applications are getting more complex, costly for development, and testing. Employees, customers, and business partners rely on these information systems to accomplish their business processes and tasks. Accordingly, users of these web applications assume that these systems are error-free and reliable. Automation testing is imperative to assure regression testing, off-load repetitive tasks from test engineers, and keep the pace between test engineers and developers. Further, it can reveal defects to test engineers at early development stages when parts of the software are broken or changed. Automated tests save time because the case gives the ability to run test cases at night and free testers to perform other types of testing, such as exploratory tests. However, even when using a dedicated automation testing framework, building test cases can be a time-consuming task. In this paper, we provide a solution for generating test cases for web applications. We present a new model-based approach that automatically generates test cases for Selenium testing tool, utilizing Domain-Specific Visual Language (DSVL) and Domain-Specific Textual Language (DSTL). Proof of concept framework is implemented and evaluated to measure user satisfaction, efficiency, and effectiveness of our approach. Our framework, named MAJD, was evaluated through a case study, using 20 tester engineers and developers from the industry with different experience levels. The results show that our framework is efficient and usable. © 2022 IEEE.},
author_keywords={Domain-Specific Languages;  Model-based testing;  Software Testing;  test case generation},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Cao2022819,
author={Cao, J. and Zhou, Y. and Sun, C. and He, L. and Xi, Z. and Liu, Y.},
title={Firebolt: Finding Bugs in Programmable Data Plane Generators},
journal={Proceedings of the 2022 USENIX Annual Technical Conference, ATC 2022},
year={2022},
pages={819-834},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85140980496&partnerID=40&md5=0e1a142e9ab3dc6dd15d8983826b6f76},
affiliation={Tsinghua University, China; Alibaba Group},
abstract={Programmable data planes (DP) enable flexible customization of packet processing logic with domain-specific languages such as P4. To relieve developers from lengthy codes and tedious hardware details, many researches propose DP program generators that take high-level intents as input and automatically convert intents into DP programs. Generators must be correct, otherwise they may produce buggy programs or DP logic that is inconsistent with intents. Nevertheless, existing verification tools are designed to verify individual DP programs, not generators. They either cannot achieve high bug coverage or cannot debug generators with high scalability. This paper presents Firebolt, a blackbox testing tool designed to dig out faults in DP program generators, including security vulnerabilities, intent violations, and generator crash. Firebolt achieves high bug coverage by using syntax-guided intent generation to construct a comprehensive, syntactically correct, and semantically valid intent set. To avoid intent explosion, Firebolt designs an intent space pruning approach that eliminates redundant intents while preserving representative ones. For high scalability, Firebolt automatically formalizes DP programs and intents for verification. We apply Firebolt to three popular open-source DP generators. Evaluation results demonstrate that Firebolt can detect 2× bugs with 0.1% to 0.01% human efforts compared to existing tools. © 2022 USENIX Annual Technical Conference, ATC 2022.All rights reserved.},
document_type={Conference Paper},
source={Scopus},
}

@ARTICLE{Zampetti2020,
author={Zampetti, F. and Di Sorbo, A. and Visaggio, C.A. and Canfora, G. and Di Penta, M.},
title={Demystifying the adoption of behavior-driven development in open source projects},
journal={Information and Software Technology},
year={2020},
volume={123},
doi={10.1016/j.infsof.2020.106311},
art_number={106311},
note={cited By 9},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85082699535&doi=10.1016%2fj.infsof.2020.106311&partnerID=40&md5=41d86560dabcd366109c4f5faad46bde},
affiliation={Department of Engineering, University of Sannio, Italy},
abstract={Context:Behavior-Driven Development (BDD) features the capability, through appropriate domain-specific languages, of specifying acceptance test cases and making them executable. The availability of frameworks such as Cucumber or RSpec makes the application of BDD possible in practice. However, it is unclear to what extent developers use such frameworks, and whether they use them for actually performing BDD, or, instead, for other purposes such as unit testing. Objective:In this paper, we conduct an empirical investigation about the use of BDD tools in open source, and how, when a BDD tool is in place, BDD specifications co-evolve with source code. Method:Our investigation includes three different phases: (i) a large-scale analysis to understand the extent to which BDD frameworks are used in 50,000 popular open-source projects written in five programming languages; (ii) a study on the co-evolution of scenarios, fixtures and production code in a sample of 20 Ruby projects, through the Granger's causality test, and (iii) a survey with 31 developers to understand how they use BDD frameworks. Results:Results of the study indicate that ≃ 27% of the sampled projects use BDD frameworks, with a prevalence in Ruby projects (68%). In about 37% of the cases, we found a co-evolution between scenarios/fixtures and production code. Specifically, changes to scenarios and fixtures often happen together or after changes to source code. Moreover, survey respondents indicate that, while they understand the intended purpose of BDD frameworks, most of them write tests while/after coding rather than strictly applying BDD. Conclusions:Even if the BDD frameworks usage is widespread among open source projects, in many cases they are used for different purposes such as unit testing activities. This mainly happens because developers felt BDD remains quite effort-prone, and its application goes beyond the simple adoption of a BDD framework. © 2020 Elsevier B.V.},
author_keywords={Acceptance testing;  Behavior-driven development;  Co-evolution;  Empirical study},
document_type={Article},
source={Scopus},
}

@CONFERENCE{Liu202047,
author={Liu, H.},
title={A Universal Automated Test Solution for Trunking Communication System},
journal={Proceedings - 2020 International Conference on Computer Engineering and Application, ICCEA 2020},
year={2020},
pages={47-51},
doi={10.1109/ICCEA50009.2020.00017},
art_number={9103781},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85086401815&doi=10.1109%2fICCEA50009.2020.00017&partnerID=40&md5=7a6362d93e52cce8a7d7448e1caf3563},
affiliation={Beijing Jiaotong University, School of Electronics and Information Engineering, Beijing, China},
abstract={In order to improve the portability of the automated test of the trunking communication system, this paper proposed a universal automated test solution for the trunking communication system. It's based on the general architecture design of the trunking communication system, providing a replaceable communication protocol codec module. With the DSL-defined test script language describing the test cases, and efficient scheduling schemes for the test task, the automated functional test and performance test of the trunking communication system are realized. Theoretical analysis and experimental results show that the minimum load test task scheduling scheme based on user operation load prediction has lower response time and lower load balancing effect compared with the traditional static task scheduling scheme. © 2020 IEEE.},
author_keywords={automated test;  component;  test task scheduling;  trunking communication},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Zanin2020,
author={Zanin, A. and Zorzo, A.F. and Nunes, H.C.},
title={Model-based testing in agile projects: An approach based on domain-specific languages},
journal={23rd Iberoamerican Conference on Software Engineering, CIbSE 2020},
year={2020},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85092302559&partnerID=40&md5=7dce86b1a8e65a1e3c4090373feca4da},
affiliation={PUCRS, Porto Alegre, Brazil},
abstract={Model-Based Testing (MBT) can bring several benefits to software quality. However, generally, MBT is applied in traditional software development lifecycle models, with few studies exploring its application in agile software development context. Hence, usually, agile development teams (AT) do not benefit from the advantages that the MBT technique provides, for example, reuse of artifacts and traceability between requirements and test artifacts. Thus, this article presents an approach for applying MBT in agile software development teams. This approach is based on the use of a semi-natural language to write scenarios for the automatic generation of models and test scripts. To exemplify the application of this approach, we also present a Domain-Specific Language (DSL) called Aquila, in which new functional test related keywords are added to the Gherkin DSL. We also present, based on a literature review, the majors challenges and difficulties of applying MBT in AT. To validate the proposed approach a Focus Group study was used. © CIbSE 2020.},
author_keywords={Agile;  DSL;  MBT;  Software Testing},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Juhnke201910,
author={Juhnke, K. and Tichy, M.},
title={A Tailored Domain Analysis Method for the Development of System-Specific Testing DSLs Enabling Their Smooth Introduction in Automotive Practice},
journal={Proceedings - 45th Euromicro Conference on Software Engineering and Advanced Applications, SEAA 2019},
year={2019},
pages={10-18},
doi={10.1109/SEAA.2019.00011},
art_number={8906733},
note={cited By 2},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85075988760&doi=10.1109%2fSEAA.2019.00011&partnerID=40&md5=3d843fd175af25bf7f5cad8e755d3945},
affiliation={Group Research and MBC Development, Daimler AG, Ulm, Germany; Institute of Software Engineering and Programming Languages, Ulm University, Ulm, Germany},
abstract={Automotive Test Case Specifications (TestSpecs) are a fundamental part of a structured test process in the automotive domain. For system and integration tests, acceptance and customer experience test cases are executed manually by human testers in a prototype vehicle. To ensure that these test cases are understood by humans, they are usually described in natural language, which often leads to ambiguities, misunderstandings, or incomplete test cases. In addition, the description of test cases vary significantly depending on the system to be tested and the respective test level. Test Designers want individual assistance in documenting their test cases with respect to system-specific characteristics, instead of using programming languages or standardized languages such as UML. Thus, Domain Specific Languages (DSLs) are a possible solution to satisfy this demand and to improve the quality of test cases, for example in terms of preciseness, uniformity, and completeness. The contribution of this paper is a systematic approach to support the development of system-specific automotive Testing DSLs that achieve high acceptance by test designers and testers. Therefore, we focus on the analysis phase in the DSL development process. We adapted domain analysis activities and defined a domain analysis method tailored to the analysis of automotive TestSpecs. We demonstrate the applicability of our method by means of five different automotive systems. Our evaluation shows that the derived system-specific Testing DSLs cover between 70% and 95% of the test steps contained in TestSpecs with only 11 to 35 conceptual templates. Moreover, a usability study with practitioners revealed a good usability of the Testing DSLs and the corresponding tool as well as that this eases the specification of test cases. © 2019 IEEE.},
author_keywords={automotive software testing;  domain analysis;  domain specific languages;  natural language test cases},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Gafurov2018749,
author={Gafurov, D. and Hurum, A.E. and Markman, M.},
title={Achieving test automation with testers without coding skills: An industrial report},
journal={ASE 2018 - Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering},
year={2018},
pages={749-756},
doi={10.1145/3238147.3240463},
note={cited By 5},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85056528902&doi=10.1145%2f3238147.3240463&partnerID=40&md5=07b833ad7afb59d7723cc0d1e0f62984},
affiliation={Norwegian Directorate of eHealth, Oslo, Norway},
abstract={We present a process driven test automation solution which enables delegating (part of) automation tasks from test automation engineer (expensive resource) to test analyst (non-developer, less expensive). In our approach, a test automation engineer implements test steps (or actions) which are executed automatically. Such automated test steps represent user actions in the system under test and specified by a natural language which is understandable by a non-technical person. Then, a test analyst with a domain knowledge organizes automated steps combined with test input to create an automated test case. It should be emphasized that the test analyst does not need to possess programming skills to create, modify or execute automated test cases. We refine benchmark test automation architecture to be better suitable for an effective separation and sharing of responsibilities between the test automation engineer (with coding skills) and test analyst (with a domain knowledge). In addition, we propose a metric to empirically estimate cooperation between test automation engineer and test analyst's works. The proposed automation solution has been defined based on our experience in the development and maintenance of Helsenorge, the national electronic health services in Norway which has had over one million of visits per month past year, and we still use it to automate the execution of regression tests. © 2018 Association for Computing Machinery.},
author_keywords={DSL for test automation;  Helsenorge;  Keyword-driven test automation;  Process-driven test automation;  Test automation},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Felderer2018,
author={Felderer, M. and Jeschko, F.},
title={A process for evidence-based engineering of domain-specific languages},
journal={ACM International Conference Proceeding Series},
year={2018},
volume={Part F137700},
doi={10.1145/3210459.3210479},
art_number={3210479},
note={cited By 2},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85053713372&doi=10.1145%2f3210459.3210479&partnerID=40&md5=fd309de170e0c9f0c6d37fca46d29ed0},
affiliation={University of Innsbruck, Department of Computer Science Innsbruck, Innsbruck, Austria; University of Innsbruck, Department of Computer Science, Innsbruck, Austria},
abstract={Domain-specific languages (DSLs) are mainly designed ad-hoc and gut feeling resulting in languages that are often not well suited for their users and engineers. In this paper we develop a process for evidence-based language engineering to design domain-specific languages based on empirical evidence to support decision in language engineering. The developed process comprises an iterative execution of the phases DSL engineering, issue identification, data collection and evidence appraisal. We exemplify the concept by designing a DSL for Gherkin, a language test-driven acceptance testing in Xtext. The required evidence is derived by mining and analyzing all GitHub projects until July 1, 2017 that apply Gherkin. © 2018 Association for Computing Machinery.},
author_keywords={Domain-specific languages;  DSL engineering;  Empirical research;  Evidence-based software engineering;  Repository mining},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{NoAuthor2018,
title={Proceedings - Asia-Pacific Software Engineering Conference, APSEC},
journal={Proceedings - Asia-Pacific Software Engineering Conference, APSEC},
year={2018},
volume={2017-December},
page_count={772},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85045873905&partnerID=40&md5=b1a1d60cc1dc48401deff64d90041c81},
abstract={The proceedings contain 93 papers. The topics discussed include: extracting traceability between predicates in event-B refinement; an improved approach to traceability recovery based on word embeddings; application of LSSVM and SMOTE on seven open source projects for predicting refactoring at class level; detecting full initialization points of objects to support code refactorings; a cloud-based trust evaluation scheme using a vehicular social network environment; Noff: a novel extendible parallel library for high-performance network traffic monitoring; a reusable framework for modeling and verifying in-vehicle networking systems in the presence of CAN and FlexRay; cost-effective regression testing using bloom filters in continuous integration development environments; correlation between the frequent use of gang-of-four design patterns and structural complexity; method level text summarization for java code using nano-patterns; flexible components for development of embedded systems with GPUs; Exniffer: learning to prioritize crashes by assessing the exploitability from memory dump; modeling and verifying identity authentication security of HDFS using CSP; a goal-driven framework in support of knowledge management; extracting insights from the topology of the JavaScript package ecosystem; improving bug localization with an enhanced convolutional neural network; mining handover process in open source development: an exploratory study; an analysis method of safety requirements for automotive software systems; and domain-specific language facilitates scheduling in model checking.},
document_type={Conference Review},
source={Scopus},
}

@ARTICLE{Häser2018147,
author={Häser, F. and Felderer, M. and Breu, R.},
title={Evaluation of an integrated tool environment for experimentation in DSL engineering},
journal={Lecture Notes in Business Information Processing},
year={2018},
volume={302},
pages={147-168},
doi={10.1007/978-3-319-71440-0_9},
note={cited By 2},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85041097449&doi=10.1007%2f978-3-319-71440-0_9&partnerID=40&md5=2b2cd5b82e6ef2bc0ba009922ab15d0d},
affiliation={Department of Computer Science, University of Innsbruck, Innsbruck, Austria},
abstract={Domain specific languages (DSL) are a popular means for providing customized solutions to a certain problem domain. So far, however, language workbenches lack sufficient built-in features in providing decision support when it comes to language design and improvement. Controlled experiments can provide data-driven decision support for both, researchers and language engineers, for comparing different languages or language features. This paper provides an evaluation of an integrated end-to-end tool environment for performing controlled experiments in DSL engineering. The experimentation environment is presented by a running example from engineering domain specific languages for acceptance testing. The tool is built on and integrated into the Meta Programming System (MPS) language workbench. For each step of an experiment the language engineer is supported by suitable DSLs and tools all within the MPS platform. The evaluation, from the viewpoint of the experiments subject, is based on the technology acceptance model (TAM). Results reveal that the subjects found the DSL experimentation environment intuitive and easy to use. © Springer International Publishing AG 2018.},
author_keywords={Domain specific languages;  DSL;  Empirical software engineering;  Experimentation;  Language engineering;  Meta Programming System;  Model-based software engineering},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{NoAuthor2017,
title={Proceedings - ACM/IEEE 20th International Conference on Model Driven Engineering Languages and Systems, MODELS 2017},
journal={Proceedings - ACM/IEEE 20th International Conference on Model Driven Engineering Languages and Systems, MODELS 2017},
year={2017},
page_count={360},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85040587063&partnerID=40&md5=da93e88a05513c5241f09ab1013fdd30},
abstract={The proceedings contain 36 papers. The topics discussed include: SQL-PL4OCL: an automatic code generator from OCL to SQL procedural language; a fuzzy logic based approach for model-based regression test selection; partial evaluation of OCL expressions; reusable specification templates for defining dynamic semantics of DSLs; active domain-specific languages: making every mobile user a modeller; experiences with teaching MPS in industry: towards bringing domain specific languages closer to practitioners; software product lines with design choices: reasoning about variability and design uncertainty; transformations of software product lines: a generalizing framework based on category theory; revisiting visitors for modular extension of executable DSMLs; from secure business process modeling to design-level security verification; why is my component and connector views specification unsatisfiable?; tool support for live formal verification; model-driven development of safety architectures; synthesis and exploration of multi-level, multi-perspective architectures of automotive embedded systems (SoSYM abstract); the next evolution of MDE: a seamless integration of machine learning into domain modeling; raising time awareness in model-driven engineering: vision paper; co-evolution of meta-modeling syntax and informal semantics in domain-specific modeling environments - a case study of AUTOSAR; heuristic-based recommendation for metamodel - OCL coevolution; ecoreification: making arbitrary java code accessible to metamodel-based tools; user experience for model-driven engineering: challenges and future directions; DREAMS toolchain: model-driven engineering of mixed-criticality systems; and bringing DSE to life: exploring the design space of an industrial automotive use case.},
document_type={Conference Review},
source={Scopus},
}

@ARTICLE{Honfi2017119,
author={Honfi, D. and Molnár, G. and Micskei, Z. and Majzik, I.},
title={Model-based regression testing of autonomous robots},
journal={Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
year={2017},
volume={10567 LNCS},
pages={119-135},
doi={10.1007/978-3-319-68015-6_8},
note={cited By 5},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85030667574&doi=10.1007%2f978-3-319-68015-6_8&partnerID=40&md5=c0ede83fdf5f839c64044a13044f7747},
affiliation={Department of Measurement and Information Systems, Budapest University of Technology and Economics, Budapest, Hungary},
abstract={Testing is a common technique to assess quality of systems. Regression testing comes into view, when changes are introduced to the system under test and re-running all tests is not practical. Numerous techniques have been introduced to select tests only relevant to a given set of changes. These are typically based on source code, however, model-based development projects use models as primary artifacts described in various domain-specific languages. Thus, regression test selection should be performed directly on these models. We present a method and a case study on how model-based regression testing can be achieved in the context of autonomous robots. The method uses information from several domain-specific languages for modeling the robot’s context and configuration. Our approach is implemented in a prototype tool, and its scalability is evaluated on models from the case study. © 2017, Springer International Publishing AG.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Laue201789,
author={Laue, R. and Storch, A. and Schnädelbach, M.},
title={Regression testing for visual models},
journal={CEUR Workshop Proceedings},
year={2017},
volume={1848},
pages={89-95},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85020554157&partnerID=40&md5=249749690bff7d9250f95ea548ab19f6},
affiliation={University of Applied Sciences Zwickau, Department of Computer Science, Dr.-Friedrichs-Ring 2a, Zwickau, 08056, Germany; It Factum GmbH, Arnulfstr. 37, Munich, 80636, Germany; Saxon Police Force, Computer and Internet Crime Unit, Germany},
abstract={In this paper, we present a set of Eclipse plug-ins which adapts the idea of regression testing for the area of visual modelling in software engineering: Expected properties of models in languages such as UML, BPMN, etc. are stored together with the model (comparable with test cases added to software). With each change of the model, these properties can be checked. The solution should work with any visual modelling language included into Eclipse - both for standardised as for domain-specific languages. The advantage of our approach over current existing solutions is that the process of model checking is completely hidden to the modeller. In particular, it is not necessary for the modeller to learn a formalism for specifying expected properties. Copyright 2017 for this paper by its authors.},
document_type={Conference Paper},
source={Scopus},
}

@ARTICLE{Poncelet2016143,
author={Poncelet, C. and Jacquemard, F.},
title={Model-based testing for building reliable realtime interactive music systems},
journal={Science of Computer Programming},
year={2016},
volume={132},
pages={143-172},
doi={10.1016/j.scico.2016.08.002},
note={cited By 2},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84994087111&doi=10.1016%2fj.scico.2016.08.002&partnerID=40&md5=3932c1c8a1b4411d05d32d0fa7eec5e7},
affiliation={IRCAM, 1 place Igor-Stravinsky, Paris, 75004, France; Sorbonne Universités, Inria, UPMC Univ Paris 06, IRCAM, CNRS UMR, SMTS, Paris, France},
abstract={The role of an Interactive Music System (IMS) is to accompany musicians during live performances, acting like a real musician. It must react in realtime to audio signals from musicians, according to a timed high-level requirement called mixed score, written in a domain specific language. Such goals imply strong requirements of temporal reliability and robustness to unforeseen errors in input, yet not much addressed by the computer music community. We present the application of Model-Based Testing techniques and tools to a state-of-the-art IMS, including in particular: offline and on-the-fly approaches for the generation of relevant input data for testing (including timing values), with coverage criteria, the computation of the corresponding expected output, according to the semantics of a given mixed score, the black-box execution of the test data on the System Under Test and the production of a verdict. Our method is based on formal models in a dedicated intermediate representation, compiled directly from mixed scores (high-level requirements), and either passed, to the model-checker Uppaal (after conversion to Timed Automata) in the offline approach, or executed by a virtual machine in the online approach. Our fully automatic framework has been applied to real mixed scores used in concerts and the results obtained have permitted to identify bugs in the target IMS. © 2016 Elsevier B.V.},
author_keywords={Interactive music systems;  Model based testing;  Timed automata},
document_type={Article},
source={Scopus},
}

@ARTICLE{Häser201652,
author={Häser, F. and Felderer, M. and Breu, R.},
title={Is business domain language support beneficial for creating test case specifications: A controlled experiment},
journal={Information and Software Technology},
year={2016},
volume={79},
pages={52-62},
doi={10.1016/j.infsof.2016.07.001},
note={cited By 16},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84990036753&doi=10.1016%2fj.infsof.2016.07.001&partnerID=40&md5=23042425f7a84d0ada295d7b9e0547d3},
affiliation={University of Innsbruck, Technikerstr. 21a, A-6020 Innsbruck, Austria},
abstract={Context: Behavior Driven Development (BDD), widely used in modern software development, enables easy creation of acceptance test case specifications and serves as a communication basis between business- and technical-oriented stakeholders. BDD is largely facilitated through simple domain specific languages (DSL) and usually restricted to technical test domain concepts. Integrating business domain concepts to implement a ubiquitous language for all members of the development team is an appealing test language improvement issue. But the integration of business domain concepts into BDD toolkits has so far not been investigated. Objective: The objective of the study presented in this paper is to examine whether supporting the ubiquitous language features inside a DSL, by extending a DSL with business domain concepts, is beneficial over using a DSL without those concepts. In the context of the study, benefit is measured in terms of perceived quality, creation time and length of the created test case specifications. In addition, we analyze if participants feel supported when using predefined business domain concepts. Method: We investigate the creation of test case specifications, similar to BDD, in a controlled student experiment performed with graduate students based on a novel platform for DSL experimentation. The experiment was carried out by two groups, each solving a similar comparable test case, one with the simple DSL, the other one with the DSL that includes business domain concepts. A crossover design was chosen for evaluating the perceived quality of the resulting specifications. Results: Our experiment indicates that a business domain aware language allows significant faster creation of documents without lowering the perceived quality. Subjects felt better supported by the DSL with business concepts. Conclusion: Based on our findings we propose that existing BDD toolkits could be further improved by integrating business domain concepts. © 2016 Elsevier B.V.},
author_keywords={Behavior driven development;  Controlled experiment;  Domain Specific Languages (DSL);  Software testing;  Student experiment},
document_type={Article},
source={Scopus},
}

@ARTICLE{Makki2016178,
author={Makki, M. and Van Landuyt, D. and Joosen, W.},
title={Automated regression testing of BPMN 2.0 processes: A capture and replay framework for continuous delivery},
journal={ACM SIGPLAN Notices},
year={2016},
volume={52},
number={3},
pages={178-189},
doi={10.1145/2993236.2993257},
note={cited By 2},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85084190357&doi=10.1145%2f2993236.2993257&partnerID=40&md5=bb4b3a3747c8e1d73b17801cc82923c9},
affiliation={IMinds-DistriNet, KU Leuven, Leuven, 3001, Belgium},
abstract={Regression testing is a form of software quality assurance (QA) that involves comparing the behavior of a newer version of a software artifact to its earlier correct behavior, and signaling the QA engineer when deviations are detected. Given the large potential in automated generation and execution of regression test cases for business process models in the context of running systems, powerful tools are required to make this practically feasible, more specifically to limit the potential impact on production systems, and to reduce the manual effort required from QA engineers. In this paper, we present a regression testing automation framework that implements the capture & replay paradigm in the context of BPMN 2.0, a domain-specific language for modeling and executing business processes. The framework employs parallelization techniques and efficient communication patterns to reduce the performance overhead of capturing. Based on inputs from the QA engineer, it manipulates the BPMN2 model before executing tests for isolating the latter from external dependencies (e.g. human actors or expensive web services) and for avoiding undesired side-effects. Finally, it performs a regression detection algorithm and reports the results to the QA engineer. We have implemented our framework on top of a BPMN2-compliant execution engine, namely jBPM, and performed functional validations and evaluations of its performance and fault-tolerance. The results, indicating 3.9% average capturing performance overhead, demonstrate that the implemented framework can be the foundation of a practical regression testing tool for BPMN 2.0, and a key enabler for continuous delivery of business process-driven applications and services. © 2016 ACM.},
author_keywords={BPMN 2.0;  Business Process Execution;  jBPM;  Node Mocking;  Performance Overhead;  Regression Testing;  Test Automation},
document_type={Article},
source={Scopus},
}

@ARTICLE{Boussaa2016202,
author={Boussaa, M. and Barais, O. and Baudry, B. and Sunyé, G.},
title={Automatic non-functional testing of code generators families},
journal={ACM SIGPLAN Notices},
year={2016},
volume={52},
number={3},
pages={202-212},
doi={10.1145/2993236.2993256},
note={cited By 1},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85084172333&doi=10.1145%2f2993236.2993256&partnerID=40&md5=3976bedc803982e1108e7fd43d89fa58},
affiliation={Diverse Team INRIA, Rennes, France; AtlanMod Team INRIA, Nantes, France},
abstract={The intensive use of generative programming techniques provides an elegant engineering solution to deal with the heterogeneity of platforms and technological stacks. The use of domain-specific languages for example, leads to the creation of numerous code generators that automatically translate highlevel system specifications into multi-target executable code. Producing correct and efficient code generator is complex and error-prone. Although software designers provide generally high-level test suites to verify the functional outcome of generated code, it remains challenging and tedious to verify the behavior of produced code in terms of non-functional properties. This paper describes a practical approach based on a runtime monitoring infrastructure to automatically check the potential inefficient code generators. This infrastructure, based on system containers as execution platforms, allows code-generator developers to evaluate the generated code performance. We evaluate our approach by analyzing the performance of Haxe, a popular high-level programming language that involves a set of cross-platform code generators. Experimental results show that our approach is able to detect some performance inconsistencies that reveal real issues in Haxe code generators. © 2016 ACM.},
author_keywords={code generator;  code quality;  non-functional properties;  testing},
document_type={Article},
source={Scopus},
}

@CONFERENCE{Boussaa2016202,
author={Boussaa, M. and Barais, O. and Baudry, B. and Sunýe, G.},
title={Automatic non-functional testing of code generators families},
journal={GPCE 2016 - Proceedings of the 2016 ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences, co-located with SPLASH 2016},
year={2016},
pages={202-212},
doi={10.1145/2993236.2993256},
note={cited By 2},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85006821065&doi=10.1145%2f2993236.2993256&partnerID=40&md5=23033cd767ef631f2e6581469ad5fe2e},
affiliation={Diverse team INRIA, Rennes, France; AtlanMod team INRIA, Nantes, France},
abstract={The intensive use of generative programming techniques provides an elegant engineering solution to deal with the heterogeneity of platforms and technological stacks. The use of domain-specific languages for example, leads to the creation of numerous code generators that automatically translate high-level system specifications into multi-Target executable code. Producing correct and efficient code generator is complex and error-prone. Although software designers provide generally high-level test suites to verify the functional outcome of generated code, it remains challenging and tedious to verify the behavior of produced code in terms of non-functional properties. This paper describes a practical approach based on a runtime monitoring infrastructure to automatically check the potential inefficient code generators. This infrastructure, based on system containers as execution platforms, allows code-generator developers to evaluate the generated code performance. We evaluate our approach by analyzing the performance of Haxe, a popular high-level programming language that involves a set of cross-platform code generators. Experimental results show that our approach is able to detect some performance inconsistencies that reveal real issues in Haxe code generators. ©2016 ACM.},
author_keywords={Code generator;  Code quality;  Non-functional properties;  Testing},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Al-Sibahi2016207,
author={Al-Sibahi, A.S. and Dimovski, A.S. and Wasowski, A.},
title={Symbolic execution of high-level transformations},
journal={SLE 2016 - Proceedings of the 2016 ACM SIGPLAN International Conference on Software Language Engineering, co-located with SPLASH 2016},
year={2016},
pages={207-220},
doi={10.1145/2997364.2997382},
note={cited By 13},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85006790383&doi=10.1145%2f2997364.2997382&partnerID=40&md5=b701466c119c446a346df19b6b2204dc},
affiliation={IT University of Copenhagen, Denmark},
abstract={Transformations form an important part of developing domain specific languages, where they are used to provide semantics for typing and evaluation. Yet, few solutions exist for verifying transformations written in expressive high-level transformation languages. We take a step towards that goal, by developing a general symbolic execution technique that handles programs written in these high-level transformation languages. We use logical constraints to describe structured symbolic values, including containment, acyclicity, simple unordered collections (sets) and to handle deep type-based querying of syntax hierarchies. We evaluate this symbolic execution technique on a collection of refactoring and model transformation programs, showing that the white-box test generation tool based on symbolic execution obtains better code coverage than a black box test generator for such programs in almost all tested cases.},
author_keywords={Automated white-box test generation;  Model transformation;  Program transformation;  Symbolic execution},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Makki2016178,
author={Makki, M. and Van Landuyt, D. and Joosen, W.},
title={Automated regression testing of BPMN 2.0 processes a capture and replay framework for continuous delivery},
journal={GPCE 2016 - Proceedings of the 2016 ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences, co-located with SPLASH 2016},
year={2016},
pages={178-189},
doi={10.1145/2993236.2993257},
note={cited By 1},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85006698880&doi=10.1145%2f2993236.2993257&partnerID=40&md5=3c116cc2fd69d4e51e8545e01e06e3e4},
affiliation={IMinds-DistriNet, KU Leuven, Leuven, 3001, Belgium},
abstract={Regression testing is a form of software quality assurance (QA) that involves comparing the behavior of a newer version of a software artifact to its earlier correct behavior, and signaling the QA engineer when deviations are detected. Given the large potential in automated generation and execution of regression test cases for business process models in the context of running systems, powerful tools are required to make this practically feasible, more specifically to limit the potential impact on production systems, and to reduce the manual effort required from QA engineers. In this paper, we present a regression testing automation framework that implements the capture & replay paradigm in the context of BPMN 2.0, a domain-specific language for modeling and executing business processes. The framework employs parallelization techniques and efficient communication patterns to reduce the performance overhead of capturing. Based on inputs from the QA engineer, it manipulates the BPMN2 model before executing tests for isolating the latter from external dependencies (e.g. human actors or expensive web services) and for avoiding undesired sideeffects. Finally, it performs a regression detection algorithm and reports the results to the QA engineer. We have implemented our framework on top of a BPMN2-compliant execution engine, namely jBPM, and performed functional validations and evaluations of its performance and fault-Tolerance. The results, indicating 3:9% average capturing performance overhead, demonstrate that the implemented framework can be the foundation of a practical regression testing tool for BPMN 2.0, and a key enabler for continuous delivery of business process-driven applications and services. ©2016 ACM.},
author_keywords={BPMN 2.0;  Business process execution;  JBPM;  Node mocking;  Performance overhead;  Regression testing;  Test automation},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Häser2016,
author={Häser, F. and Felderer, M. and Breu, R.},
title={An integrated tool environment for experimentation in domain specific language engineering},
journal={ACM International Conference Proceeding Series},
year={2016},
volume={01-03-June-2016},
doi={10.1145/2915970.2916010},
art_number={a20},
note={cited By 6},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84978496761&doi=10.1145%2f2915970.2916010&partnerID=40&md5=759eb12218bda8990778c15d174a8bb4},
affiliation={Institute of Computer Science, University of Innsbruck, Austria},
abstract={Domain specific languages (DSLs) are widely used in practice and investigated in software engineering research. But so far, language workbenches do not provide sufficient builtin decision support for language design and improvement. Controlled experiments have the potential to provide appropriate, data-driven decision support for language engineers and researchers to compare different language features with evidence-based feedback. This paper provides an integrated end-to-end tool environment to perform controlled experiments in DSL engineering. The experiment environment is built on the basis and integrated into the language workbench Meta Programming System (MPS). The environment not only supports language design but also all steps of experimentation, i.e., planning, operation, analysis & interpretation, as well as presentation & package. The tool environment is presented by means of a running example experiment comparing the time taken to create system acceptance tests for web applications in two different DSLs. © 2016 ACM.},
author_keywords={Controlled experiment;  Domain Specific Languages (DSLs);  Empirical evaluation;  Experimentation;  Language engineering;  Meta Programming System (MPS);  Tool support},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{NoAuthor2016,
title={ACM International Conference Proceeding Series},
journal={ACM International Conference Proceeding Series},
year={2016},
volume={Part F128404},
page_count={182},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85046053536&partnerID=40&md5=0474c10feb1b62d0561df8aa88aa843f},
abstract={The proceedings contain 18 papers. The topics discussed include: deeply reifying running code for constructing a domain-specific language; a distributed selectors runtime system for Java applications; efficient memory traces with full pointer information; extraction-based regression test selection; inference and checking of object immutability; integrating asynchronous task parallelism and data-centric atomicity; JCrypt: towards computation over encrypted data; multi-tier data synchronization based on an optimized concurrent linked-list; preexistence and concrete type analysis in the context of multiple inheritance; and prioritizing regression tests for desktop and web-applications based on the execution frequency of modified code.},
document_type={Conference Review},
source={Scopus},
}

@ARTICLE{NoAuthor20161,
title={16th International Symposium on Trends in Functional Programming, TFP 2015},
journal={Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
year={2016},
volume={9547},
pages={1-156},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84978701156&partnerID=40&md5=630b3015b0a82b152ed973383152d937},
abstract={The proceedings contain 8 papers. The special focus in this conference is on Trends in Functional Programming. The topics include: lightweight higher-order rewriting in haskell; towards a theory of reach; functional testing of java programs; type class instances for type-level lambdas in haskell; on the role of slicing in functional data-flow programming; a shallow embedded type safe extendable DSL for the arduino and programmable signatures and termination proofs for recursive functions in FoCaLiZe.},
document_type={Conference Review},
source={Scopus},
}

@ARTICLE{NoAuthor20161,
title={15th International Conference on Software Reuse, ICSR 2016},
journal={Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
year={2016},
volume={9679},
pages={1-411},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84977492303&partnerID=40&md5=347f932969ae9dfb1c178ad3143fa5af},
abstract={The proceedings contain 29 papers. The special focus in this conference is on Software Product Lines, Business Aspects of Software Reuse, Component-Based Reuse, Reuse-Based Software Engineering and Software Reuse Tools. The topics include: Applying incremental model slicing to product-line regression testing; automated composition of service mashups through software product line engineering; feature location in model-based software product lines through a genetic algorithm; carrying ideas from knowledge-based configuration to software product lines; a method to support the adoption of reuse technology in large software organizations; a practical use case modeling approach to specify crosscutting concerns; an approach for prioritizing software features based on node centrality in probability network; rage reusable game software components and their integration into serious game engines; reusable secure connectors for secure software architecture; concept-based engineering of situation-specific migration methods; leveraging feature location to extract the clone-and-own relationships of a family of software products; an architecture to improve software reuse; pragmatic software reuse in bioinformatics; feature location benchmark for software families using eclipse community releases; java extensions for design pattern instantiation; towards a semantic search engine for open source software; detecting similar programs via the weisfeiler-leman graph kernel; a semi automatic maintenance of OCL constraints; reverse-engineering reusable language modules from legacy domain-specific languages; a framework for enhancing the retrieval of UML diagrams; a tool for analyzing and extracting specification clones in DSLS and a tool to support decision making for component reuse through profiling with ontologies.},
document_type={Conference Review},
source={Scopus},
}

@CONFERENCE{Kumar2015,
author={Kumar, R. and Kumar, V.},
title={Process optimization for testing of domain specific languages in industrial automation},
journal={2015 World Congress on Information Technology and Computer Applications, WCITCA 2015},
year={2015},
doi={10.1109/WCITCA.2015.7367051},
art_number={7367051},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84962473616&doi=10.1109%2fWCITCA.2015.7367051&partnerID=40&md5=47d0b26a48ce3ed250a04d194aa96212},
affiliation={Siemens Technologies and Services limited, Bangalore, India},
abstract={Software testing is essential part of software development. The goal of the testing process is not only to enhance the quality and robustness of the software but also verify the correctness and non functional requirements of the software under all working conditions. Large software has their large testing suites to verify the stability of legacy features. Testing processes have huge challenges to maintain effectiveness and efficiency of the legacy test cases. There are many different processes and techniques available all technique or processes have their advantages and limitations. A tailored testing process has been tried to utilize all technique together to improvise the benefits and efficiency of testing in the industrial automation domain. This paper tries to explain a customized approach of utilizing the available testing techniques in such a way that it enhances the effectiveness and efficiency of regression testing, thus improving the time to market of large product-line Industrial automation software. © 2015 IEEE.},
author_keywords={Industial automation;  Regression testing;  Software testing process;  Test automation;  Test effectiveness;  Test suite optimization},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Poncelet20151759,
author={Poncelet, C. and Jacquemard, F.},
title={Model based testing of an interactive music system},
journal={Proceedings of the ACM Symposium on Applied Computing},
year={2015},
volume={13-17-April-2015},
pages={1759-1764},
doi={10.1145/2695664.2695804},
note={cited By 5},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84955496249&doi=10.1145%2f2695664.2695804&partnerID=40&md5=a00d9e874cc02eefa7097d0df6d69b47},
affiliation={DGA, INRIA, Ircam (Umr Smts-cnrs/upmc), France},
abstract={The role of an interactive music system (IMS) is to accompany musicians during live performances, like a real musician. It reacts in realtime to audio signals from musicians, according to a timed specification called mixed score, written in a domain specific language. Such goals imply strong requirements of temporal reliability and robustness to unforeseen errors in input, yet not so much studied in the computer music community. We present the application of model-based testing techniques and tools to a state-of-the-art IMS, including the following tasks: generation of relevant input data for testing (including timing values) following coverage criteria, computation of the corresponding expected output, according to the semantics of a given mixed score, black-box execution of the test data and verdict. Our method is based on formal models compiled directly from mixed scores, and passed, after conversion to timed automata, to the model-checker Uppaal. This fully automatic approach has been applied to real mixed scores used in concerts and the results obtained have permitted to identify bugs in the target IMS. Copyright 2015 ACM.},
author_keywords={Computer music domain specific languages;  Interactive music systems;  Model based testing;  Realtime systems;  Timed automata},
document_type={Conference Paper},
source={Scopus},
}

@ARTICLE{Selim2015365,
author={Selim, G.M.K. and Wang, S. and Cordy, J.R. and Dingel, J.},
title={Model transformations for migrating legacy deployment models in the automotive industry},
journal={Software and Systems Modeling},
year={2015},
volume={14},
number={1},
pages={365-381},
doi={10.1007/s10270-013-0365-1},
note={cited By 9},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84922338189&doi=10.1007%2fs10270-013-0365-1&partnerID=40&md5=cb7ae64fdf0c3556171f4b91381d82e1},
affiliation={School of Computing, Queen’s University, Kingston, ON  K7L2N8, Canada; Electrical and Controls Integration Lab, General Motors Research and Development, Warren, MI  48090, United States},
abstract={Many companies in the automotive industry have adopted model-driven development in their vehicle software development. As a major automotive company, General Motors (GM) has been using a custom-built, domain-specific modeling language, implemented as an internal proprietary metamodel, to meet the modeling needs in its control software development. Since AUTomotive Open System ARchitecture (AUTOSAR) has been developed as a standard to ease the process of integrating components provided by different suppliers and manufacturers, there has been a growing demand to migrate these GM-specific, legacy models to AUTOSAR models. Given that AUTOSAR defines its own metamodel for various system artifacts in automotive software development, we explore applying model transformations to address the challenges in migrating GM-specific, legacy models to their AUTOSAR equivalents. As a case study, we have built and validated a model transformation using the MDWorkbench tool, the Atlas Transformation Language, and the Metamodel Coverage Checker tool. This paper reports on the case study, makes observations based on our experience to assist in the development of similar types of transformations, and provides recommendations for further research. © 2013, Springer-Verlag Berlin Heidelberg.},
author_keywords={Automotive control software;  AUTOSAR;  Black-box testing;  Model transformations;  Model-driven development (MDD);  Transformation languages and tools},
document_type={Article},
source={Scopus},
}

@CONFERENCE{Häser2014156,
author={Häser, F. and Felderer, M. and Breu, R.},
title={Test process improvement with documentation driven integration testing},
journal={Proceedings - 2014 9th International Conference on the Quality of Information and Communications Technology, QUATIC 2014},
year={2014},
pages={156-161},
doi={10.1109/QUATIC.2014.29},
art_number={6984109},
note={cited By 3},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84921059614&doi=10.1109%2fQUATIC.2014.29&partnerID=40&md5=634d14b73fda52a267350bb24816c632},
affiliation={Institute of Computer Science Quality Engineering, University of Innsbruck, Austria},
abstract={Improving the maturity of the test process in an organization, especially but not limited to integration testing, involves obstacles and risks, such as the additional work overhead of the new process. In addition, integration testing descriptions are often too technical not addressing the language needs of the domain. In research cooperations with companies from the insurance and banking domain it turned out that test descriptions and reports are one of the most useful testing artifacts, while doing adhoc testing. This paper presents a bottom up testing approach, which first helps the integration tester in producing a semi-formal test description and report, up to be an enabler for automatic model-based testing in the very end. The presented approach is based on a textual domain specific language that is able to evolve over time. This is done by analyzing the test descriptions and reports automatically with machine learning techniques as well as manually by integration testers. Often recurring test steps or used components are integrated into the test language, making it specially tailored for a specific organization. For each test step implementations can be attached, preparing it for the next iteration. In this paper the methodology and architecture of our integration testing approach are presented together with the underlying language concepts. © 2014 IEEE.},
author_keywords={Model-Based Integration Testing;  Regression Testing;  Test Process Improvement},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{King2014409,
author={King, T.M. and Nunez, G. and Santiago, D. and Cando, A. and Mack, C.},
title={Legend: An agile DSL toolset for web acceptance testing},
journal={2014 International Symposium on Software Testing and Analysis, ISSTA 2014 - Proceedings},
year={2014},
pages={409-412},
doi={10.1145/2610384.2628048},
note={cited By 4},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84942796278&doi=10.1145%2f2610384.2628048&partnerID=40&md5=e1b8e6f6bcaf8bf9f6d7650b26038563},
affiliation={Ultimate Software Group Inc., 2000 Ultimate Way, Weston, FL  33326, United States},
abstract={Agile development emphasizes collaborations among customers, business analysts, domain experts, developers, and testers. However, the large scale and rapid pace of many agile projects presents challenges during testing activities. Large sets of test artifacts must be comprehensible and available to various stakeholders, traceable to requirements, and easily maintainable as the software evolves. In this paper we describe Legend, a toolset that leverages domain-specific language to streamline functional testing in agile projects. Some key features of the toolset include test template generation from user stories, model-based automation, test inventory synchronization, and centralized test tagging. Copyright 2014 ACM.},
author_keywords={Agile development;  Behavior-driven development;  Domain-specific languages;  Software testing;  Test automation},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Martinez201413,
author={Martinez, J. and Thomas, T. and King, T.M.},
title={Echo: A middleware architecture for domain-specific UI test automation},
journal={2014 Workshop on Joining AcadeMiA and Industry Contributions to Test Automation and Model-Based Testing, JAMAICA 2014 - Proceedings},
year={2014},
pages={13-15},
doi={10.1145/2631890.2631893},
note={cited By 2},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84942409801&doi=10.1145%2f2631890.2631893&partnerID=40&md5=580120dfa5f66ea5514ea211d228169b},
affiliation={Ultimate Software Group, Inc., 2000 Ultimate Way, Weston, FL  33326, United States},
abstract={Model-driven engineering (MDE) continues to raise the level of abstraction used in software development. Software testing researchers and practitioners have been adopting MDE principles, and applying them to software testing activities. Examples include the use of domain-specific languages for functional testing and test automation. In this paper we present the design of a layered middleware architecture to support domain-specific, functional UI test automation. Building on experiences gained implementing a Selenium- based framework for a large-scale agile project, we present design ideas that raise the abstraction level in UI test automation frameworks. Design considerations are discussed to provoke thoughts and ideas on automation frameworks. Copyright 2014 ACM.},
author_keywords={Domain-specific languages;  Middleware;  Software architecture;  Software testing;  Test automation;  User interfaces},
document_type={Conference Paper},
source={Scopus},
}

@ARTICLE{Bache2014320,
author={Bache, E. and Bache, G.},
title={Specification by example with gui tests - how could that work?},
journal={Lecture Notes in Business Information Processing},
year={2014},
volume={179 LNBIP},
pages={320-326},
doi={10.1007/978-3-319-06862-6_26},
note={cited By 5},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84904569844&doi=10.1007%2f978-3-319-06862-6_26&partnerID=40&md5=31a1d19d98862c19765b2fc95d31a409},
affiliation={Bache Consulting, Göteborg, Sweden; Jeppesen Systems, Göteborg, Sweden},
abstract={Specification by Example is a collaborative method for developing software. It involves a workshop where people representing various roles and viewpoints discuss what is to be built, and come up with concrete example scenarios. These scenarios later form the basis for automated (functional) acceptance tests, and are sometimes called "Living Documentation", as they are written in a Domain Specific Language and can be read by non-programmers. GUI testing has traditionally used a record-replay paradigm that requires the user interface exists before the tests can be created, and hence have been considered incompatible with a Specification by Example approach. In this experience report we will discuss how we have overcome this apparent contradiction at Jeppesen, and relate an experience using the tool TextTest for GUI testing of Jeppesen's next-generation Crew Management System. © Springer International Publishing Switzerland 2014.},
author_keywords={ATDD;  Capture-Replay Testing;  GUI testing;  Specification by Example},
document_type={Conference Paper},
source={Scopus},
}

@ARTICLE{Crapo2013215,
author={Crapo, A. and Moitra, A.},
title={TOWARD A UNIFIED ENGLISH-LIKE REPRESENTATION of SEMANTIC MODELS, DATA, and GRAPH PATTERNS for SUBJECT MATTER EXPERTS},
journal={International Journal of Semantic Computing},
year={2013},
volume={7},
number={3},
pages={215-236},
doi={10.1142/S1793351X13500025},
note={cited By 30},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84979072313&doi=10.1142%2fS1793351X13500025&partnerID=40&md5=d3fa8959aa767deb824b345f36de8c0a},
affiliation={GE Global Research, Niskayuna, NY  12309, United States},
abstract={The Semantic Application Design Language (SADL) combines advances in standardized declarative modeling languages based on formal logic with advances in domain-specific language (DSL) development environments to create a controlled-English language that translates directly into the Web Ontology Language (OWL), the SPARQL graph query language, and a compatible if/then rule language. Models in the SADL language can be authored, tested, and maintained in an Eclipse-based integrated development environment (IDE). This environment offers semantic highlighting, statement completion, expression templates, hyperlinking of concepts to their definition, model validation, automatic error correction, and other advanced authoring features to enhance the ease and productivity of the modeling environment. In addition, the SADL language offers the ability to build in validation tests and test suites that can be used for regression testing. Through common Eclipse functionality, the models can be easily placed under source code control, versioned, and managed throughout the life of the model. Differences between versions can be compared side-by-side. Finally, the SADL-IDE offers an explanation capability that is useful in understanding what was inferred by the reasoner/rule engine and why those conclusions were reached. Perhaps more importantly, explanation is available of why an expected inference failed to occur. The objective of the language and the IDE is to enable domain experts to play a more active and productive role in capturing their knowledge and making it available as computable artifacts useful for automation where appropriate and for decision support systems in applications that benefit from a collaborative human-computer approach. SADL is built entirely on open source code and most of SADL is itself released to open source. This paper explores the concepts behind the language and provides details and examples of the authoring and model lifecycle support facilities. © 2013 World Scientific Publishing Company.},
author_keywords={Controlled English;  graph pattern;  ontology;  OWL;  semantic model},
document_type={Article},
source={Scopus},
}

@ARTICLE{NoAuthor2012,
title={Computer Applications for Software Engineering, Disaster Recovery, and Business Continuity - International Conferences, ASEA and DRBC 2012, Held in Conjunction with GST 2012, Proceedings},
journal={Communications in Computer and Information Science},
year={2012},
volume={340 CCIS},
page_count={475},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84869847795&partnerID=40&md5=50ed69d3acd9f3c6e6b80204eec1482c},
abstract={The proceedings contain 62 papers. The topics discussed include: impact on realistic mobility model for aircraft ad hoc networks; technology network model using bipartite social network analysis; mobile application development using component features and inheritance; view, level and fragment: commonalities in 'Architecture 101' and software modelling; highly analysable, reusable, and realisable architectural designs with XCD; ARSL: a domain specific language for aircraft separation minima determination; regression testing of object-oriented software: a technique based on use cases and associated tool; development of an instant meeting Android application using Wi-Fi direct APIs; developer support for understanding preprocessor macro expansions; towards building method level maintainability models based on expert evaluations; and a study on the improved stability of inverter through history management of semiconductor elements for power supply.},
document_type={Conference Review},
source={Scopus},
}

@ARTICLE{Woskowski201262,
author={Woskowski, C.},
title={Applying industrial-strength testing techniques to critical care medical equipment},
journal={Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
year={2012},
volume={7612 LNCS},
pages={62-73},
doi={10.1007/978-3-642-33678-2_6},
note={cited By 4},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84867588659&doi=10.1007%2f978-3-642-33678-2_6&partnerID=40&md5=56dc43ec05802ce8928510e60a23002c},
affiliation={Zühlke Engineering GmbH, Landshuter Allee 12, 80637 München, Germany},
abstract={Hardware and software development of embedded systems interdependently gear into each other. Even more so if the device under development is intended for use in critical care facilities such as intensive care units. Especially in this case, safety measures and risk mitigation techniques are implemented using both hardware and software components. Thus applying hardware and software testing approaches in combination is inevitable as well. The increasing utilization of test domain-specific languages (Test DSLs), code generators and keyword-driven interpreters tends to raise the level of abstraction in test development. This approach aims to enhance productivity by generating executable tests from a non-programming language created for describing test cases. A second goal is to increase coverage by generating tests for as many as possible combinations of input values (black box test) or for all reasonable paths of a program flow (white box test). In combination with hardware-supported signal generation and fault injection this can be a very powerful strategy for testing safety-critical embedded devices. This article introduces an example of this strategy - the usage of a keyword-driven testing technique in cooperation with additional test hardware - in the context of an embedded medical device development, all the while emphasizing the benefit of combining different approaches. It discusses the utilization of commercial off-the-shelf (COTS) testing hardware as well as the application of an in-house developed test box. It also highlights the integration of commercial software - for requirements engineering, test management and continuous integration - with a self-developed testing framework powered by its own keyword-based test DSL. © 2012 Springer-Verlag.},
author_keywords={domainspecific language;  embedded system;  keyword-driven;  medical device;  safety-critical;  testing hardware},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Hallenberg201296,
author={Hallenberg, N. and Carlsen, P.L.},
title={Declarative automated test},
journal={2012 7th International Workshop on Automation of Software Test, AST 2012 - Proceedings},
year={2012},
pages={96-102},
doi={10.1109/IWAST.2012.6228998},
art_number={6228998},
note={cited By 2},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84864262119&doi=10.1109%2fIWAST.2012.6228998&partnerID=40&md5=670bdf6333dc0c334ffece1b49a7898c},
affiliation={SimCorp., Copenhagen, Denmark},
abstract={Automated tests at the business level can be expensive to develop and maintain. One common approach is to have a domain expert instruct a QA developer to implement what she would do manually in the application. Though there exist record-replay tools specifically developed for this, these tend to scale poorly for more complicated test scenarios. We present a different solution: An Embedded Domain Specific Language (EDSL) in F#, containing the means to model the user interface, and the various manipulations of it. We hope that this DSL will bridge the gap between the business domain and technical domain of applications to such a degree that domain experts may be able to construct automatic tests without depending on QA developers, and that these tests will prove more maintainable. © 2012 IEEE.},
author_keywords={Automated Testing;  Domain Specific Language;  F#;  Functional Testing},
document_type={Conference Paper},
source={Scopus},
}

@ARTICLE{NoAuthor2012,
title={Modelling Foundations and Applications - 8th European Conference, ECMFA 2012, Proceedings},
journal={Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
year={2012},
volume={7349 LNCS},
page_count={441},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84864064431&partnerID=40&md5=d47a39e66a5c67e0c272e4c3e5157203},
abstract={The proceedings contain 30 papers. The topics discussed include: executable UML: from multi-domain to multi-core; models meeting automotive design challenges; a commutative model composition operator to support software adaptation; comparative study of model-based and multi-domain system engineering approaches for industrial settings; strengthening SAT-based validation of UML/OCL models by representing collections as relations; model interchange testing: a process and a case study; an internal domain-specific language for constructing OPC UA queries and event filters; combining UML sequence and state machine diagrams for data-flow based integration testing; model transformations for migrating legacy models: an industrial case study; derived features for EMF by integrating advanced model queries; a lightweight approach for managing XML documents with MDE languages; and bridging the gap between requirements and aspect state machines to support non-functional testing: industrial case studies.},
document_type={Conference Review},
source={Scopus},
}

@ARTICLE{LunaRobles2011297,
author={Luna Robles, E. and Rossi, G. and Garrigós, I.},
title={WebSpec: A visual language for specifying interaction and navigation requirements in web applications},
journal={Requirements Engineering},
year={2011},
volume={16},
number={4},
pages={297-321},
doi={10.1007/s00766-011-0124-1},
note={cited By 22},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-80355133393&doi=10.1007%2fs00766-011-0124-1&partnerID=40&md5=f1f0f0c473c59f609af650d777b886c7},
affiliation={LIFIA, Facultad de Informática, UNLP, La Plata, Argentina; CICPBA, Buenos Aires, Argentina; Conicet, La Plata, Argentina; Lucentia Research Group, DLSI, University of Alicante, Alicante, Spain},
abstract={Web application development is a complex and time-consuming process that involves different stakeholders (ranging from customers to developers); these applications have some unique characteristics like navigational access to information, sophisticated interaction features, etc. However, there have been few proposals to represent those requirements that are specific to Web applications. Consequently, validation of requirements (e. g., in acceptance tests) is usually informal and as a result troublesome. To overcome these problems, we present WebSpec, a domain-specific language for specifying the most relevant and characteristic requirements of Web applications: those involving interaction and navigation. We describe WebSpec diagrams, discussing their abstraction and expressive power. With a simple though realistic example, we show how we have used WebSpec in the context of an agile Web development approach discussing several issues such as automatic test generation, management of changes in requirements, and improving the understanding of the diagrams through application simulation. © 2011 Springer-Verlag London Limited.},
author_keywords={Code generation;  Interaction;  Simulation;  Testing;  Web requirements},
document_type={Article},
source={Scopus},
}

@CONFERENCE{Prasetya2011,
author={Prasetya, I.S.W.B. and Amorim, J. and Vos, T.E.J. and Baars, A.},
title={Using Haskell to script combinatoric testing of web services},
journal={Proceedings of the 6th Iberian Conference on Information Systems and Technologies, CISTI 2011},
year={2011},
art_number={5974321},
note={cited By 1},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-80052440645&partnerID=40&md5=5cef5a3d5aadbdfa7acfc8a4db258387},
affiliation={Dept. of Inf. and Comp. Sciences, Utrecht University, Netherlands; Dept. de Sist. Informaticos Y Comp., Univ. Polit. de Valencia, Spain},
abstract={The Classification Tree Method (CTM) is a popular approach in functional testing as it allows the testers to systematically partition the input domain of an SUT, and specifies the combinations they want. We have implemented the approach as a small domain specific language (DSL) embedded in the functional language Haskell. Such an embedding leads to clean syntax and moreover we can natively access Haskell's full features. This paper will explain the approach, and how it is applied for testing Web Services. © 2011 AISTI.},
author_keywords={automated testing;  combinatoric testing},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Strasser20104687,
author={Strasser, T. and Peters, T. and Jägle, H. and Zrenner, E. and Wilke, R.},
title={An integrated domain specific language for post-processing and visualizing electrophysiological signals in Java},
journal={2010 Annual International Conference of the IEEE Engineering in Medicine and Biology Society, EMBC'10},
year={2010},
pages={4687-4690},
doi={10.1109/IEMBS.2010.5626417},
art_number={5626417},
note={cited By 4},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-78650837400&doi=10.1109%2fIEMBS.2010.5626417&partnerID=40&md5=7b2189cb0d2e385f46d1ec94c4ff7f22},
affiliation={Institute for Ophthalmic Research, Centre for Ophthalmology, University of Tuebingen, Tuebingen, Germany; School of Biomedical Engineering, University of New South Wales, Sydney, Australia; Pediatric and Neuro-Ophthalmology, Orbital-and Hereditary Eye Diseases, University Eye Clinic Regensburg, Regensburg, Germany},
abstract={Electrophysiology of vision - especially the electroretinogram (ERG) - is used as a non-invasive way for functional testing of the visual system. The ERG is a combined electrical response generated by neural and non-neuronal cells in the retina in response to light stimulation. This response can be recorded and used for diagnosis of numerous disorders. For both clinical practice and clinical trials it is important to process those signals in an accurate and fast way and to provide the results as structured, consistent reports. Therefore, we developed a freely available and open-source framework in Java (http://www.eye.uni-tuebingen.de/projectlidsI4sigproc). The framework is focused on an easy integration with existing applications. By leveraging well-established software patterns like pipes-and-filters and fluent interfaces as well as by designing the application programming interfaces (API) as an integrated domain specific language (DSL) the overall framework provides a smooth learning curve. Additionally, it already contains several processing methods and visualization features and can be extended easily by implementing the provided interfaces. In this way, not only can new processing methods be added but the framework can also be adopted for other areas of signal processing. This article describes in detail the structure and implementation of the framework and demonstrate its application through the software package used in clinical practice and clinical trials at the University Eye Hospital Tuebingen one of the largest departments in the field of visual electrophysiology in Europe. © 2010 IEEE.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{Vanderbauwhede2010141,
author={Vanderbauwhede, W. and Margala, M. and Chalamalasetti, S.R. and Purohit, S.},
title={A C++-embedded domain-specific language for programming the MORA soft processor array},
journal={Proceedings of the International Conference on Application-Specific Systems, Architectures and Processors},
year={2010},
pages={141-148},
doi={10.1109/ASAP.2010.5540750},
art_number={5540750},
note={cited By 10},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-77955948453&doi=10.1109%2fASAP.2010.5540750&partnerID=40&md5=ac257e54a23c83c1dbcc8c531fe9b659},
affiliation={Dept. of Computing Science, University of Glasgow, Glasgow, United Kingdom; Dept. of Electrical and Computer Engineering, University of Massachusetts at Lowell, Lowell, MA, United States},
abstract={MORA is a novel platform for high-level FPGA programming of streaming vector and matrix operations, aimed at multimedia applications. It consists of soft array of pipelined low-complexity SIMD processors-in-memory (PIM). We present a Domain-Specific Language (DSL) for high-level programming of the MORA soft processor array. The DSL is embedded in C++, providing designers with a familiar language framework and the ability to compile designs using a standard compiler for functional testing before generating the FPGA bitstream using the MORA toolchain. The paper discusses the MORA-C++ DSL and the compilation route into the assembly for the MORA machine and provides examples to illustrate the programming model and performance. © 2010 IEEE.},
author_keywords={Domain-Specific language;  Multimedia processing;  Reconfigurable processor;  Soft processor array},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{NoAuthor2009,
title={Proceedings of EuroPLoP 2009 - 14th Annual European Conference on Pattern Languages of Programming},
journal={Proceedings of EuroPLoP 2009 - 14th Annual European Conference on Pattern Languages of Programming},
year={2009},
page_count={607},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-84865211969&partnerID=40&md5=3e4e738b74f93ed5406f7903066944c5},
abstract={The proceedings contain 32 papers. The topics discussed include: enterprise architecture management patterns for enterprise architecture visioning; roles in a software project; applied pattern for strategy management for technology entrepreneurship and innovation MSc program; performance of open source projects; the role of analysis patterns in systems analysis; applying architectural patterns for parallel programming: solving the one-dimensional heat equation; towards formalized adaptation patterns for adaptive interactive systems; a pattern driven approach against architectural knowledge vaporization; reusable architectural decisions for DSL design: foundational decisions in DSL projects; a pattern vocabulary for project distribution; business patterns for knowledge audit implementation; applying distributed development patterns; and a pattern language of black-box test design for reactive software systems.},
document_type={Conference Review},
source={Scopus},
}

@CONFERENCE{Talby2009154,
author={Talby, D.},
title={The perceived value of authoring and automating acceptance tests using a model driven development toolset},
journal={Proceedings of the 2009 ICSE Workshop on Automation of Software Test, AST 2009},
year={2009},
pages={154-157},
doi={10.1109/IWAST.2009.5069055},
art_number={5069055},
note={cited By 1},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-70349673934&doi=10.1109%2fIWAST.2009.5069055&partnerID=40&md5=48d78d31c56c55d68b8be3f60af589cb},
affiliation={Hebrew University of Jerusalem, Israel},
abstract={One approach to applying keyword driven testing in a model-driven development environment is by defining a domain specific language for test cases. The toolset then provides test editors, versioning, validation, reporting and hyperlinks across models - in addition to enabling automated test execution. This case study evaluates the effectiveness of such a solution as perceived by two teams of professional testers, who used it to test several products over a two year period. The results suggest that in addition to the expected benefits of automation, the solution reduces the time and effort required to write tests, maintain tests and plan the test authoring and execution efforts - at the expense of requiring longer training and a higher bar for recruiting testers.},
document_type={Conference Paper},
source={Scopus},
}

@CONFERENCE{NoAuthor2008,
title={Software Engineering 2008 - Fachtagung des GI-Fachbereichs Softwaretechnik},
journal={Lecture Notes in Informatics (LNI), Proceedings - Series of the Gesellschaft fur Informatik (GI)},
year={2008},
volume={P-121},
page_count={301},
note={cited By 0},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-85135817088&partnerID=40&md5=92cd9eb678ac694dec744b22590a3fd2},
abstract={The proceedings contain 36 papers. The topics discussed include: connecting good theory to good practice: software documentation: a case study; assisting needs driven requirements engineering with the ARIS toolset; eliminating trust from application programs by way of software architecture; towards automatic construction of reusable prediction models for component-based performance engineering; towards effective management of software knowledge exploiting the semantic wiki paradigm; towards a peer-to-peer based global software development environment; combining structural and functional test case generation; Monaco: a DSL approach for programming automation systems; and workshop agile knowledge sharing for distributed software teams.},
document_type={Conference Review},
source={Scopus},
}

@ARTICLE{Sinha2006242,
author={Sinha, A. and Smidts, C.},
title={HOTTest: A model-based test design technique for enhanced testing of domain-specific applications},
journal={ACM Transactions on Software Engineering and Methodology},
year={2006},
volume={15},
number={3},
pages={242-278},
doi={10.1145/1151695.1151697},
note={cited By 11},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-33748528112&doi=10.1145%2f1151695.1151697&partnerID=40&md5=396688bb148f87f73f3face6aa31322c},
affiliation={IBM T. J. Watson Research Center, United States; University of Maryland, United States; IBM T. J. Watson Research Center, 19 Skyline Drive, 2NF07, Hawthorne, NY 10562, United States; Center for Risk and Reliability Engineering, University of Maryland, MD 20742, United States},
abstract={Model-based testing is an effective black-box test generation technique for applications. Existing model-based testing techniques, however, fail to capture implicit domain-specific properties, as they overtly rely on software artifacts such as design documents, requirement specifications, etc., for completeness of the test model. This article presents a technique, HOTTest, which uses a strongly typed domain-specific language to model the system under test. This allows extraction of type-related system invariants, which can be related to various domain-specific properties of the application. Thus, using HOTTest, it is possible to automatically extract and embed domain-specific requirements into the test models. In this article we describe HOTTest, its principles and methodology, and how it is possible to relate domain-specific properties to specific type constraints. HOTTest is described using the example of HaskellDB, which is a Haskell-based embedded domain-specific language for relational databases. We present an example application of the technique and compare the results to some other commonly used Model-based test automation techniques like ASML-based testing, UML-based testing, and EFSM-based testing. © 2006 ACM.},
author_keywords={Database-specific test case generation;  Domain-specific languages;  Domain-specific testing;  Haskell;  HaskellDB;  Model-based testing;  Test case generation;  Test generation tools},
document_type={Article},
source={Scopus},
}

@CONFERENCE{Massey2002175,
author={Massey, M.C. and Parrish, B.E. and McMullen, W.E. and Estes, T.J.},
title={Plastic ball grid arrays, a qualified packaging technology for high reliability space applications},
journal={Proceedings of SPIE - The International Society for Optical Engineering},
year={2002},
volume={4828},
pages={175-180},
note={cited By 1},
url={https://www.scopus.com/inward/record.uri?eid=2-s2.0-0036421992&partnerID=40&md5=a3770f2bf2f77e11db4aaa1b18e08e14},
affiliation={TRW Electronic Systems/Technol. Div., One Space Park, 201/4035, Redondo Beach, CA 90278, United States},
abstract={TRW has qualified a new advanced digital packaging technology for critical space applications; Plastic Ball Grid Array (PBGA) assemblies. This achievement enables use of high I/O, state-of-the-art ASIC designs and promises improved digital subsystem performance at significantly reduced weight and cost. Plastic ball grid array packages accommodating die as large as 17 mm sq. with over 800 I/O are planned on future satellite programs surviving extensive component-level and product-level qualification testing. TRW's space-qualification of laminate-based (organic) area array packaging technology responds to the ever increasing demand for reliable, cost effective, high density interconnect (HDI) solutions while leveraging the commercial standard plastic encapsulated microcircuit (PEM). This paper describes the product line approach used to produce qualification test vehicles representative of proposed flight configurations. TRW's radiation hardened 32-bit processor ASIC was used as an electrically functional test vehicle. The initial research focused on package reliability without hermeticity (RWOH) and solder joint reliability. Test results from a controlled insertion of plastic ball grid array packages on flight-like dual sequential laminated (DSL) boards are presented, where thousands of solder joints are continuously monitored using an inexpensive and highly reliable on-board fault detection circuit. The data demonstrates how this technology can provide a superior integrated circuit (IC) packaging solution over traditional ceramic-based assemblies. Space programs will benefit from aggressive insertion of JEDEC standard PBGA packages to achieve higher performance designs with increased circuit densities, while reducing electronic product's size, weight, power, and cost.},
author_keywords={Dual sequential laminated (DSL);  High density interconnect (HDI);  Integrated circuit (IC);  Plastic ball grid array (PBGA);  Plastic encapsulated microcircuit (PEM);  Radiation-hardened 32-bit processor (RH32);  Reliability without hermeticity (RWOH)},
document_type={Conference Paper},
source={Scopus},
}
